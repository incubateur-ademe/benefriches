# Domain Events Pattern

> **Event-driven communication** for cross-module interactions and side effects.

## Overview

Domain events enable decoupled, event-driven communication between modules and trigger side effects (audit logging, analytics, notifications). Events are created using factory functions, published from UseCases (preferred) or controllers (rare), and consumed by listeners in other modules. This pattern prevents direct module dependencies while maintaining loose coupling.

## Core Principles

1. **Factory Functions**: Events created via factory functions in `*.event.ts` files
2. **UseCases Publish**: Events published from UseCases (business logic), sometimes from controllers
3. **Typed Events**: Events use typed payloads with `DomainEvent<Name, Payload>` structure
4. **Past Tense Naming**: Event names use past tense (`"example.created"`, not `"example.create"`)
5. **Cross-Module Decoupling**: Modules communicate via events, not direct imports
6. **Optional Side Effects**: Events trigger side effects without blocking main flow

## When to Use Domain Events

Use domain events when you need:
- **Cross-module communication** (avoid direct module dependencies)
- **Audit logging** (track what happened in the system)
- **Analytics** (business event tracking)
- **Side effects** (send emails, notifications, external API calls)
- **Eventual consistency** (coordinating changes across modules)

## Event Structure

### Event Definition

Events are defined in `core/events/*.event.ts` files:

```typescript
// core/events/exampleCreated.event.ts
import type { DomainEvent } from "src/shared-kernel/domainEvent";

export const EXAMPLE_CREATED = "example.created";

export type ExampleCreatedEvent = DomainEvent<
  typeof EXAMPLE_CREATED,
  {
    exampleId: string;
    name: string;
    createdBy: string;
    createdAt: Date;
  }
>;

// Factory function to create the event
// Event ID is provided by UidGenerator in the UseCase (see Publishing Events section)
export function createExampleCreatedEvent(
  id: string,  // Event ID generated by UseCase's UidGenerator
  payload: ExampleCreatedEvent["payload"]
): ExampleCreatedEvent {
  return {
    id,  // Use provided ID
    name: EXAMPLE_CREATED,
    payload,
  };
}
```

**Reference Examples**:
* [auth/core/events/userAccountCreated.event.ts](../../../apps/api/src/auth/core/events/userAccountCreated.event.ts)
* [apps/api/src/sites/core/events/siteCreated.event.ts](../../../apps/api/src/sites/core/events/siteCreated.event.ts)
* [apps/api/src/auth/core/events/loginSucceeded.event.ts](../../../apps/api/src/auth/core/events/loginSucceeded.event.ts)

### Event Naming Convention

- **Event constant**: `UPPER_SNAKE_CASE` → `EXAMPLE_CREATED`, `USER_ACCOUNT_CREATED`
- **Event type**: `PascalCase` + `Event` suffix → `ExampleCreatedEvent`, `UserAccountCreatedEvent`
- **Event name**: Domain name + past tense → `"example.created"`, `"user.accountCreated"`

## Publishing Events

### In UseCases (Preferred)

**CRITICAL**: UseCases publishing events MUST inject `UidGenerator` to generate event IDs:

```typescript
import type { DomainEventPublisher } from "src/shared-kernel/domainEvent";
import type { UidGenerator } from "src/shared-kernel/adapters/id-generator/UidGenerator";
import { createExampleCreatedEvent } from "../events/exampleCreated.event";

export class CreateExampleUseCase implements UseCase<Request, TResult<Response, Errors>> {
  constructor(
    private readonly repository: ExampleRepository,
    private readonly eventPublisher: DomainEventPublisher,
    private readonly uuidGenerator: UidGenerator,  // Generate event IDs
  ) {}

  async execute(request: Request): Promise<TResult<Response, Errors>> {
    // Business logic
    const example = createExample(request);
    await this.repository.save(example);

    // Publish event using factory function
    // Pass generated event ID as first parameter
    await this.eventPublisher.publish(
      createExampleCreatedEvent(
        this.uuidGenerator.generate(),  // Generate event ID
        {
          exampleId: example.id,
          name: example.name,
          createdBy: request.userId,
          createdAt: new Date(),
        }
      )
    );

    return success({ exampleId: example.id });
  }
}
```

**Why UidGenerator?**
- ✅ Event IDs must be generated, not hardcoded
- ✅ Allows tests to use deterministic IDs for predictable behavior
- ✅ Factory function receives ID from UseCase (no UUID randomness inside factory)

### In Controllers (Rare Cases Only)

**IMPORTANT**: This pattern is **rare** and should only be used in specific cases where:
- The logic is tightly coupled to HTTP layer concerns (authentication, ProConnect flow)
- The event represents an HTTP-layer event, not a domain event
- Publishing from UseCase would add unnecessary complexity

**Real-World Example**: [auth/adapters/auth.controller.ts:175](../../../apps/api/src/auth/adapters/auth.controller.ts#L175)

In the Auth module, `loginAttempted` and `loginSucceeded` events are published from the controller because they represent authentication flow events (HTTP layer concern), not domain business logic.

```typescript
import { DOMAIN_EVENT_PUBLISHER_INJECTION_TOKEN } from "src/shared-kernel/adapters/events/eventPublisher.module";
import type { DomainEventPublisher } from "src/shared-kernel/domainEventPublisher";
import { UUID_GENERATOR_INJECTION_TOKEN, type UidGenerator } from "src/shared-kernel/adapters/id-generator/UidGenerator";

@Controller("auth")
export class AuthController {
  constructor(
    private readonly authenticateUseCase: AuthenticateUseCase,
    @Inject(DOMAIN_EVENT_PUBLISHER_INJECTION_TOKEN)
    private readonly eventPublisher: DomainEventPublisher,
    @Inject(UUID_GENERATOR_INJECTION_TOKEN)
    private readonly uidGenerator: UidGenerator,
  ) {}

  @Get("pro-connect/callback")
  async proConnectCallback(@Query() query: ProConnectCallbackQuery) {
    // Authentication logic...

    // Publish login attempted event (HTTP-layer event)
    await this.eventPublisher.publish(
      createLoginAttemptedEvent(this.uidGenerator.generate(), {
        method: "pro-connect",
      })
    );

    const result = await this.authenticateUseCase.execute(/* ... */);

    if (result.isSuccess()) {
      // Publish login succeeded event
      await this.eventPublisher.publish(
        createLoginSucceededEvent(this.uidGenerator.generate(), {
          userId: user.id,
          userEmail: user.email,
          method: "pro-connect",
        })
      );
    }

    // Return response...
  }
}
```

**Why publish in controller here?**
- These events track authentication attempts at the HTTP layer
- They're not domain business events (user creation, data changes)
- The UseCase (`AuthenticateUseCase`) is focused on core authentication logic

**General Rule**: Prefer publishing from UseCases. Only publish from controllers when the event is truly an HTTP-layer concern.

## Listening to Events

### Event Listener with Dependencies (Factory Pattern)

When a listener needs injected dependencies (gateways, services, DateProvider), use the factory pattern:

```typescript
// marketing/adapters/primary/loginSucceeded.handler.ts
import { Injectable } from "@nestjs/common";
import { OnEvent } from "@nestjs/event-emitter";
import { LOGIN_SUCCEEDED, type LoginSucceededEvent } from "src/auth/core/events/loginSucceeded.event";
import { DateProvider } from "src/shared-kernel/adapters/date/IDateProvider";
import { CRMGateway } from "src/marketing/core/CRMGateway";

@Injectable()
export class LoginSucceededHandler {
  constructor(
    private readonly crm: CRMGateway,
    private readonly dateProvider: DateProvider,
  ) {}

  @OnEvent(LOGIN_SUCCEEDED)
  async handleLoginSucceeded(event: LoginSucceededEvent) {
    // Use injected DateProvider for testable timestamps
    await this.crm.updateContactLastLoginDate(
      event.payload.userEmail,
      this.dateProvider.now(),
    );
  }
}
```

**Register in module using factory pattern**:

```typescript
// marketing/adapters/primary/marketing.module.ts
@Module({
  imports: [HttpModule, ConfigModule],
  providers: [
    {
      provide: LoginSucceededHandler,
      useFactory: (crm: CRMGateway, dateProvider: DateProvider) =>
        new LoginSucceededHandler(crm, dateProvider),
      inject: [ConnectCrm, RealDateProvider],  // Inject concrete implementations
    },
    RealDateProvider,  // Register production implementation
    ConnectCrm,
  ],
})
export class MarketingModule {}
```

**Why this pattern?**
- **DateProvider**: Use `RealDateProvider` in production, `DeterministicDateProvider` in tests for predictable behavior
- **CRMGateway**: Interface injected, concrete implementation provided via `ConnectCrm`
- **Testability**: Override providers in test with fakes/deterministic implementations (see [06-integration-testing-pattern.md](06-integration-testing-pattern.md))

**Real Example**: [marketing/adapters/primary/loginSucceeded.handler.ts](../../../apps/api/src/marketing/adapters/primary/loginSucceeded.handler.ts)

## Dependency Injection

### UseCase with Event Publisher (ALWAYS Use Direct Injection)

**CRITICAL**: When a UseCase publishes events, ALWAYS use direct injection of `RealEventPublisher` and `RandomUuidGenerator`:

```typescript
import { RealEventPublisher } from "src/shared-kernel/adapters/events/publisher/RealEventPublisher";
import { RandomUuidGenerator } from "src/shared-kernel/adapters/id-generator/RandomUuidGenerator";
import type { DomainEventPublisher } from "src/shared-kernel/domainEvent";
import type { UidGenerator } from "src/shared-kernel/adapters/id-generator/UidGenerator";

@Module({
  imports: [EventPublisherModule],  // Import event publisher infrastructure
  providers: [
    {
      provide: CreateExampleUseCase,
      useFactory: (
        repository: ExampleRepository,
        eventPublisher: RealEventPublisher,  // Direct injection (NOT token)
        uuidGenerator: RandomUuidGenerator,   // For generating event IDs
      ) => new CreateExampleUseCase(repository, eventPublisher, uuidGenerator),
      inject: [
        ExampleRepository,
        RealEventPublisher,      // Inject concrete implementation directly
        RandomUuidGenerator,     // Inject concrete implementation directly
      ],
    },
    RealEventPublisher,   // Register concrete implementation
    RandomUuidGenerator,  // Register concrete implementation
  ],
})
export class ExampleModule {}
```

**Why direct injection**:
- ✅ Clearer intent - no indirection via tokens
- ✅ More testable - tests inject `InMemoryEventPublisher` + `RandomUuidGenerator`
- ✅ Better DI practices - inject what you use directly
- ✅ UidGenerator required for event ID generation in factory functions

**Real example**: [sites.module.ts](../../../apps/api/src/sites/adapters/primary/sites.module.ts) (Line 68-82)

### Controller with Event Publisher (Rare Cases Only)

ONLY use injection tokens for controllers publishing HTTP-layer events:

```typescript
@Module({
  imports: [EventPublisherModule],
  controllers: [ExampleController],
  providers: [
    // HTTP-layer events published from controller
    // Use injection tokens via @Inject decorator in controller
  ],
})
export class ExampleModule {}
```

Then in controller:

```typescript
import { DOMAIN_EVENT_PUBLISHER_INJECTION_TOKEN } from "src/shared-kernel/adapters/events/eventPublisher.module";
import { UUID_GENERATOR_INJECTION_TOKEN } from "src/shared-kernel/adapters/id-generator/UidGenerator";
import { Inject } from "@nestjs/common";

@Controller("examples")
export class ExampleController {
  constructor(
    @Inject(DOMAIN_EVENT_PUBLISHER_INJECTION_TOKEN)
    private readonly eventPublisher: DomainEventPublisher,
    @Inject(UUID_GENERATOR_INJECTION_TOKEN)
    private readonly uidGenerator: UidGenerator,
  ) {}
}
```

**When to use tokens in controllers**:
- ⚠️ ONLY for HTTP-layer events (authentication, login tracking)
- ⚠️ ONLY when tightly coupled to HTTP request handling
- ❌ Do NOT use for business domain events - move to UseCase instead

**Real example**: [auth.controller.ts](../../../apps/api/src/auth/adapters/auth.controller.ts) (Lines 154-159)

## Common Shared Services

**For event publishing**:

| Service | Import | When to Use |
|---------|--------|-------------|
| **DomainEventPublisher** | `src/shared-kernel/domainEvent` | Type interface for dependency injection |
| **RealEventPublisher** | `src/shared-kernel/adapters/events/publisher/RealEventPublisher` | Concrete implementation for UseCase direct injection (ALWAYS use this) |
| **RandomUuidGenerator** | `src/shared-kernel/adapters/id-generator/RandomUuidGenerator` | Generate event IDs in UseCases (required for event factory functions) |
| **DOMAIN_EVENT_PUBLISHER_INJECTION_TOKEN** | `src/shared-kernel/adapters/events/eventPublisher.module` | Injection token (ONLY for controllers publishing HTTP-layer events) |
| **EventPublisherModule** | `src/shared-kernel/adapters/events/eventPublisher.module` | Module import (required in all modules using events) |

**For event listeners needing side effects** (see [11-shared-services.md](11-shared-services.md)):

| Service | Import | When to Use |
|---------|--------|-------------|
| **DateProvider** | `src/shared-kernel/adapters/date/IDateProvider` | Type interface for testable timestamps |
| **RealDateProvider** | `src/shared-kernel/adapters/date/RealDateProvider` | Production date provider |
| **DeterministicDateProvider** | `src/shared-kernel/adapters/date/DeterministicDateProvider` | Test fixtures with fixed dates |
| **Gateway interfaces** | Domain-specific | Side effect execution (HTTP, databases) |

## Best Practices

### DO:
- ✅ Use factory functions to create events (for consistency and testability)
- ✅ Define events in `core/events/*.event.ts` files
- ✅ Publish events from UseCases (preferred)
- ✅ Use past tense for event names (`created`, not `create`)
- ✅ Include all relevant context in event payload
- ✅ Use typed event interfaces
- ✅ Inject shared services (DateProvider, gateways) into listeners for testable side effects
- ✅ Use `DeterministicDateProvider` in tests for predictable behavior

### DON'T:
- ❌ Don't create events inline (use factory functions)
- ❌ Don't include sensitive data in event payloads
- ❌ Don't use events for synchronous validation (use Result pattern)
- ❌ Don't create tight coupling via events (events should be optional side effects)

## Related Patterns

- **UseCases**: [01-usecase-pattern.md](01-usecase-pattern.md) (emitting events from business logic)
- **Dependency Injection**: [08-dependency-injection.md](08-dependency-injection.md) (wiring event publishers and listeners)
- **Shared Services**: [11-shared-services.md](11-shared-services.md) (DateProvider, ID generators for testability)
- **Integration Testing**: [06-integration-testing-pattern.md](06-integration-testing-pattern.md) (testing listeners with overridden providers)